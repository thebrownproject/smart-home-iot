# Data Model: Comprehensive Smart Home Automation System

**Branch**: `001-comprehensive-smart-home` | **Date**: 2025-09-17
**Generated by**: Phase 1 - Design & Contracts

## Core Entities

### Environmental Data
**Purpose**: Temperature, humidity, and environmental sensor readings
**Storage**: Time-series data with cloud persistence

```python
class EnvironmentalReading:
    timestamp: datetime       # ISO format with timezone
    sensor_type: str         # "temperature", "humidity", "gas"
    value: float             # Sensor reading value
    unit: str                # "celsius", "percent", "ppm"
    location: str            # "indoor", "outdoor", room identifier
    device_id: str           # ESP32 unique identifier
    status: str              # "normal", "warning", "critical"
```

**Validation Rules**:
- temperature: -40.0 to 85.0 celsius (DHT11 range)
- humidity: 0.0 to 100.0 percent
- gas: 0 to 1023 (analog reading), critical > 500
- timestamp: must be within 5 minutes of server time

### Access Records
**Purpose**: RFID card access attempts and door control events
**Storage**: Relational with user identification

```python
class AccessRecord:
    record_id: str           # UUID primary key
    timestamp: datetime      # Access attempt time
    card_uid: str            # RFID card unique identifier
    access_granted: bool     # True if authorized card
    door_action: str         # "unlock", "lock", "blocked"
    user_name: str           # Associated user name (if registered)
    device_id: str           # ESP32 identifier
    location: str            # Door location identifier
```

**Validation Rules**:
- card_uid: 8-character hex string (RC522 format)
- user_name: 1-50 characters, alphanumeric + spaces
- door_action: enum ["unlock", "lock", "blocked", "error"]

### Security Events
**Purpose**: Motion detection, PIR sensor alerts, and security status
**Storage**: Event log with severity classification

```python
class SecurityEvent:
    event_id: str            # UUID primary key
    timestamp: datetime      # Event occurrence time
    event_type: str          # "motion", "pir", "manual_override"
    severity: str            # "info", "warning", "alert"
    triggered_by: str        # Sensor identifier or "manual"
    response_actions: list   # Actions taken by system
    resolved: bool           # Event acknowledged/resolved
    device_id: str           # ESP32 identifier
    location: str            # Sensor location
```

**Validation Rules**:
- event_type: enum ["motion", "pir", "manual_override", "system_arm", "system_disarm"]
- severity: enum ["info", "warning", "alert", "critical"]
- response_actions: list of strings from predefined action set

### System States
**Purpose**: Current operational modes and device status
**Storage**: Current state with historical snapshots

```python
class SystemState:
    state_id: str            # Current state identifier
    timestamp: datetime      # State change time
    pir_enabled: bool        # PIR security system status
    gas_alarm_active: bool   # Gas detection system status
    manual_overrides: dict   # Active manual overrides
    device_status: dict      # Individual component health
    network_status: str      # "connected", "disconnected", "error"
    last_heartbeat: datetime # Last successful communication
    device_id: str           # ESP32 identifier
```

**Validation Rules**:
- manual_overrides: dict with component names as keys, override status as values
- device_status: dict with component health ["online", "offline", "error", "unknown"]
- network_status: enum ["connected", "disconnected", "connecting", "error"]

### Emergency Protocols
**Purpose**: Gas detection emergency response and safety procedures
**Storage**: Emergency event log with response tracking

```python
class EmergencyEvent:
    emergency_id: str        # UUID primary key
    timestamp: datetime      # Emergency detection time
    emergency_type: str      # "gas_detected", "system_failure"
    severity_level: int      # 1-5 scale (5 = critical)
    triggered_by: str        # Sensor that detected emergency
    response_sequence: list  # Ordered list of automated responses
    manual_disable: bool     # Emergency manually disabled
    resolved_at: datetime    # Emergency resolution time
    device_id: str           # ESP32 identifier
```

**Validation Rules**:
- severity_level: integer 1-5, determines response intensity
- response_sequence: ordered list of actions ["open_doors", "open_windows", "activate_fan", "sound_alarm", "flash_lights"]
- resolved_at: must be after timestamp if provided

## State Transitions

### PIR Security System
```
States: [disabled] ↔ [enabled] → [triggered] → [resolving] → [enabled]
Triggers:
- disabled → enabled: button_2_press OR manual_command
- enabled → triggered: pir_motion_detected
- triggered → resolving: motion_stopped_for_30s
- resolving → enabled: system_reset_complete
- any → disabled: button_2_press OR emergency_override
```

### Gas Emergency Protocol
```
States: [monitoring] → [detected] → [emergency_active] → [manual_disabled] → [monitoring]
Triggers:
- monitoring → detected: gas_sensor_reading > threshold
- detected → emergency_active: confirmation_reading_after_2s
- emergency_active → manual_disabled: button_1_press
- manual_disabled → monitoring: manual_reset OR 1_hour_timeout
```

### Door Access Control
```
States: [locked] ↔ [unlocked] → [auto_lock_pending] → [locked]
Triggers:
- locked → unlocked: authorized_rfid_detected
- unlocked → auto_lock_pending: 30_second_timer
- auto_lock_pending → locked: timer_expired OR manual_lock
- unlocked → locked: emergency_protocol_active
```

## Relationships

### User → Access Records (1:N)
- Users can have multiple RFID cards
- Access records link to user through card_uid
- User table stores authorized cards and permissions

### Device → All Events (1:N)
- Single ESP32 device generates all event types
- Device health tracked through heartbeat messages
- Historical device data retained for diagnostics

### Emergency → Response Actions (1:N)
- Each emergency event triggers multiple response actions
- Response actions logged with timestamps and success status
- Failed actions trigger backup response procedures

## Database Schema (Supabase PostgreSQL)

```sql
-- Environmental readings table
CREATE TABLE environmental_readings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    sensor_type VARCHAR(20) NOT NULL,
    value NUMERIC(10,2) NOT NULL,
    unit VARCHAR(10) NOT NULL,
    location VARCHAR(50) NOT NULL,
    device_id VARCHAR(32) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'normal'
);

-- Access control table
CREATE TABLE access_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    card_uid VARCHAR(8) NOT NULL,
    access_granted BOOLEAN NOT NULL,
    door_action VARCHAR(20) NOT NULL,
    user_name VARCHAR(50),
    device_id VARCHAR(32) NOT NULL,
    location VARCHAR(50) NOT NULL DEFAULT 'main_door'
);

-- Security events table
CREATE TABLE security_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    event_type VARCHAR(30) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    triggered_by VARCHAR(50) NOT NULL,
    response_actions JSONB,
    resolved BOOLEAN NOT NULL DEFAULT FALSE,
    device_id VARCHAR(32) NOT NULL,
    location VARCHAR(50) NOT NULL
);

-- System state table (current state only)
CREATE TABLE system_state (
    device_id VARCHAR(32) PRIMARY KEY,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    pir_enabled BOOLEAN NOT NULL DEFAULT TRUE,
    gas_alarm_active BOOLEAN NOT NULL DEFAULT FALSE,
    manual_overrides JSONB,
    device_status JSONB,
    network_status VARCHAR(20) NOT NULL DEFAULT 'disconnected',
    last_heartbeat TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Emergency events table
CREATE TABLE emergency_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    emergency_type VARCHAR(30) NOT NULL,
    severity_level INTEGER NOT NULL CHECK (severity_level BETWEEN 1 AND 5),
    triggered_by VARCHAR(50) NOT NULL,
    response_sequence JSONB NOT NULL,
    manual_disable BOOLEAN NOT NULL DEFAULT FALSE,
    resolved_at TIMESTAMPTZ,
    device_id VARCHAR(32) NOT NULL
);

-- Authorized users table
CREATE TABLE authorized_users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_name VARCHAR(50) NOT NULL UNIQUE,
    card_uid VARCHAR(8) NOT NULL UNIQUE,
    active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_access TIMESTAMPTZ
);

-- Indexes for performance
CREATE INDEX idx_env_timestamp ON environmental_readings(timestamp DESC);
CREATE INDEX idx_env_device_type ON environmental_readings(device_id, sensor_type);
CREATE INDEX idx_access_timestamp ON access_records(timestamp DESC);
CREATE INDEX idx_access_card ON access_records(card_uid);
CREATE INDEX idx_security_timestamp ON security_events(timestamp DESC);
CREATE INDEX idx_security_unresolved ON security_events(resolved) WHERE resolved = FALSE;
CREATE INDEX idx_emergency_timestamp ON emergency_events(timestamp DESC);
CREATE INDEX idx_emergency_unresolved ON emergency_events(resolved_at) WHERE resolved_at IS NULL;
```

## Local Data Caching

ESP32 maintains local circular buffers for network outages:
- Environmental readings: 100 entries
- Access attempts: 50 entries
- Security events: 50 entries
- Emergency events: 20 entries (highest priority for sync)

Data synchronization occurs every 30 seconds when network available, with retry exponential backoff on failure.